vec3 ray_direction(mat4 inv_projection, mat4 inv_view,
                   float x, float y) {
  vec4 ray_clip = vec4(x, y, -1.0, 1.0);
  vec4 ray_eye = inv_projection * ray_clip;
  ray_eye.zw = vec2(-1.0, 0.0);
  vec4 ray_world = inv_view * ray_eye;
  return normalize(ray_world.xyz);
}

vec3 ray_origin(mat4 inv_view) {
  return (inv_view * vec4(vec3(0.0), 1.0)).xyz;
}

vec3 sample_lambert(float rand1, float rand2) {
  float n1 = rand1;
  float r = sqrt(n1);

  float azimuth = rand2 * M_PI * 2.0 + sobol_rotation;

  float x = r*cos(azimuth);
  float z = r*sin(azimuth);
  float y = sqrt(1.0 - r*r);

  return vec3(x, y, z);
}

vec3 sample_ggx(float roughness, float rand1, float rand2) {
  float azimuth = rand2 * M_PI * 2.0 + sobol_rotation;
  float rand = rand1;

  float alpha = roughness*roughness;
  float a2 = alpha*alpha;

  float cos_elevation = sqrt((1-rand)/(1+(a2-1)*rand));
  float sin_elevation = sqrt(1.0 - cos_elevation*cos_elevation);

  float x = sin_elevation*cos(azimuth);
  float y = cos_elevation;
  float z = sin_elevation*sin(azimuth);

  return vec3(x, y, z);
}

vec2 sample_disk(float rand1, float rand2) {
  float r = sqrt(rand1);
  float theta = 2*M_PI*rand2 + sobol_rotation;
  return vec2(r*sin(theta), r*cos(theta));
}

float ggx(vec3 normal, vec3 x, float roughness) {
  float r2 = roughness * roughness;
  float r4 = r2*r2;

  float k = dot(normal, x);
  float k2 = k*k;

  float d = k2*(r4 - 1.0) + 1.0;
  return r4/(M_PI * d*d);
}

float fresnel_schlick(vec3 normal, vec3 view, float r0) {
  return r0 + (1 - r0)*pow(1 - clamp(dot(normal, view), 0.0, 1.0), 5);
}

float g_cook_torrance(vec3 normal, vec3 half_vector,
                      vec3 incident_vector, vec3 eye_vector) {
  float dot_vh = clamp(dot(eye_vector, half_vector), 1e-6, 1.0);
  float dot_nh = clamp(dot(normal, half_vector), 0.0, 1.0);
  float dot_nv = clamp(dot(normal, eye_vector), 0.0, 1.0);
  float dot_nl = clamp(dot(normal, incident_vector), 0.0, 1.0);

  float x = 2*dot_nh/dot_vh;
  return min(1.0, min(x*dot_nl, x*dot_nv));
  return min(1.0, min(2 * dot_nh * dot_nv / dot_vh,
                      2 * dot_nh * dot_nl / dot_vh));
}

float g_factor(float dot_nl, float dot_nv, float roughness) {
  float r = (roughness + 1.0);
  float k = r*r/8.0;
  k = roughness*roughness/2.0;
  float gl = 1.0/(dot_nl*(1-k)+k);
  float gv = 1.0/(dot_nv*(1-k)+k);
  return gl*gv;
}

float ggx_lambda(vec3 normal, vec3 w, float roughness) {
  float alpha = roughness*roughness;
  float cos_theta = dot(normal, w);
  float cos2_theta = cos_theta*cos_theta;
  float sin2_theta = 1 - cos2_theta;
  float tan2_theta = sin2_theta / cos2_theta;
  return -1.0 + sqrt(1.0 +  tan2_theta) / 2.0;
}

float cook_torrance(vec3 normal, vec3 half_vector,
                    vec3 incident_vector, vec3 eye_vector,
                    float roughness, float r0) {
  float dot_nl = clamp(dot(normal, incident_vector), 0.0, 1.0);
  float dot_nv = clamp(dot(normal, eye_vector), 0.0, 1.0);

  half_vector = normalize(eye_vector + incident_vector);

  if (dot_nl > 0.0 && dot_nv > 1e-3) {
    /* Canceled out by PDF */
    // float D = ggx(normal, half_vector, roughness);
    float D = 1.0;
    /* Canceled out by Russian roulette */
    /* float F = fresnel_schlick(normal, eye_vector, r0); */
    float F = 1.0;
    float G = g_cook_torrance(normal, half_vector, incident_vector, eye_vector);
    /* dot_nl in the denominator canceled out by cosine term */
    /* 4 factor in denominator canceled out by PDF for GGX */
    return (D*F*G)/dot_nv;
  }
  else
    return 0.0;
}

vec3 normal_to_world(vec3 normal, vec3 x) {
  vec3 t1 = vec3(1.0, 0.0, 0.0);
  if (abs(normal.x) > 0.6)
    t1 = vec3(0.0, 1.0, 0.0);

  vec3 t2 = normalize(cross(t1, normal));
  t1 = cross(t2, normal);

  return x.x*t1 + x.y*normal + x.z*t2;
}

vec3 sample_light(float rand1, float rand2) {
  vec2 pos2d = LIGHT_RADIUS * sample_disk(rand1, rand2);
  return vec3(pos2d.x, 10.0, pos2d.y);
}

vec3 path_trace(Ray incident_ray, uint sample_id) {
  vec3 result = vec3(0.0);
  vec3 factor = vec3(1.0);
  bool from_specular = true;

  for (int i = 0; i < NUM_BOUNCES; i++) {
    Intersection intersection = trace_ray(incident_ray);

    /* No subgroup/workgroup ballot instructions in WGPU :( */

    /* if (allInvocationsARB(intersection.distance == MAX_DISTANCE)) */
    /*   return result; */

    sobol_setup(i+1);
    float rand1 = sobol_next(0, sample_id);
    float rand2 = sobol_next(1, sample_id);
    float rand3 = sobol_next(2, sample_id);

    if (intersection.distance == MAX_DISTANCE)
      continue;

    Material mat = intersection.material;
    if (from_specular)
      result += factor * mat.emittance;

    vec3 eye = -incident_ray.direction;

    float F = fresnel_schlick(intersection.normal, eye, 0.5);
    float prob = mix(F, 1.0, mat.metalness);
    float layer = rand3;

    vec3 random_dir;

    if (layer <= prob) {
      random_dir = sample_ggx(
        mat.roughness, rand1, rand2);
      random_dir = normal_to_world(intersection.normal, random_dir);
      vec3 half_vector = random_dir;
      random_dir = reflect(incident_ray.direction, half_vector);

      /* float pdf = M_PI / (dot(half_vector, intersection.normal)); */

      /* Canceled out by D term in Cook-Torrance */
      /* pdf *= ggx(intersection.normal, half_vector, mat.roughness); */
      /* Canceled out by denominator in cook torrance */
      /* pdf /= 4*/

      float inv_pdf = dot(half_vector, intersection.normal) / M_PI;

      float specular = cook_torrance(intersection.normal, half_vector,
                                     random_dir, eye,
                                     mat.roughness, 0.5);
      specular *= inv_pdf;

      vec3 brdf = specular * mix(vec3(1.0), mat.albedo, mat.metalness);

      from_specular = true;
      factor *= brdf;
      if (dot(random_dir, intersection.normal) <= 1e-3) factor = vec3(0.0);
    }
    else {
      random_dir = sample_lambert(rand1, rand2);
      random_dir = normal_to_world(intersection.normal, random_dir);
      factor *= (1-mat.metalness)*mat.albedo;
      /* (1-F) factor canceled out because of Russian roulette */
    }

    incident_ray = Ray(intersection.pos + 1e-2*random_dir, random_dir);
  }

  return result;
}

shared vec4 old;
shared vec3 data[32];

void main() {
  ivec2 pixel_coords = ivec2(gl_WorkGroupID.xy);
  ivec2 pixel_size = imageSize(result) / ivec2(4, 1);

  if (gl_LocalInvocationIndex == 0) {
    if (reset == 0)
      old = vec4(0.0);
    else {
      old.r = imageLoad(result, ivec2(4, 1) * pixel_coords + ivec2(0, 0)).r;
      old.g = imageLoad(result, ivec2(4, 1) * pixel_coords + ivec2(1, 0)).r;
      old.b = imageLoad(result, ivec2(4, 1) * pixel_coords + ivec2(2, 0)).r;
      old.a = imageLoad(result, ivec2(4, 1) * pixel_coords + ivec2(3, 0)).r;
    }
  }

  barrier();

  uint sample_id = 1024 + uint(old.a) + NUM_SAMPLES*gl_LocalInvocationIndex;
  setup_rotation(sample_id);

  vec3 new = vec3(0.0);
  for (uint i = 0; i < NUM_SAMPLES; i++) {
    sobol_setup(0);
    float off_r = sqrt(sobol_next(0, sample_id+i));
    float off_angle = 2*M_PI*sobol_next(1, sample_id+i) + sobol_rotation;

    float off_x = off_r * cos(off_angle);
    float off_y = off_r * sin(off_angle);

    float y = (pixel_coords.y + off_y)/(pixel_size.y*0.5) - 1.0;
    float x = (pixel_coords.x + off_x)/(pixel_size.x*0.5) - 1.0;
    y *= -1.0;

    Ray ray = Ray(
      (camera.inv_view * vec4(vec3(0.0), 1.0)).xyz,
      vec3(1.0, 1.0, 1.0)*ray_direction(camera.inv_projection, camera.inv_view, x, y));
    new += path_trace(ray, sample_id+i);
  }

  new.r = min(new.r, 10.0);
  new.g = min(new.g, 10.0);
  new.b = min(new.b, 10.0);
  data[gl_LocalInvocationIndex] = new;
  int size = WORK_GROUP_SIZE;
  for (int size = WORK_GROUP_SIZE >> 1; size != 0; size >>= 1) {
    barrier();
    if (gl_LocalInvocationIndex < size)
      data[gl_LocalInvocationIndex] += data[gl_LocalInvocationIndex + size];
  }

  if (gl_LocalInvocationIndex == 0) {
    imageStore(result, ivec2(4, 1) * pixel_coords + ivec2(0, 0), vec4(old.r + data[0].r));
    imageStore(result, ivec2(4, 1) * pixel_coords + ivec2(1, 0), vec4(old.g + data[0].g));
    imageStore(result, ivec2(4, 1) * pixel_coords + ivec2(2, 0), vec4(old.b + data[0].b));
    imageStore(result, ivec2(4, 1) * pixel_coords + ivec2(3, 0), vec4(old.a + NUM_SAMPLES*WORK_GROUP_SIZE));
  }
}
